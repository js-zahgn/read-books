1、栈
	栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。
	function Stack(){
		var items = [];
		// 添加元素
		this.push = function(ele){
			items.push(ele);
		}
		// 移除并返回最后一个元素
		this.pop = function(){
			return items.pop();
		}
		// 返回最后一个元素
		this.peek = function(){
			return items[items.length - 1];
		}
		this.isEmpty = function(){
			return items.length < 1;
		}
		this.clear = function(){
			items = [];
		}
		this.size = function(){
			return items.length;
		}
	}
	
	// 将十进制数字转化为其他进制
	function baseConverter(num, base){
		var res = [],
			digits = '0123456789ABCDEF';
		
		while(num > 0){
			res.unshift(num % base);
			num = Math.floor(num / base);
		}
				
		return res.map(function(item){
			return digits[item]
		}).join('');
	}

2、队列
	队列是遵循先进先出(FIFO)原则的一组有序的想。队列的尾部添加新元素，并从顶部移除元素。
	function Queue(){
		var items = [];
		// 添加元素
		this.enqueue = function(ele){
			items.push(ele);
		}
		// 移除并返回队列中的第一个元素
		this.dequeue = function(){
			return items.shift();
		}
		// 返回队列中第一个元素
		this.front = function(){
			return items[0]
		}
		this.isEmpty = function(){
			return items.length < 1;
		}
		this.clear = function(){
			items = [];
		}
		this.size = function(){
			return items.length;
		}
	}
	
	// 优先级队列
	function PriorityQueue(){
		var items = [];
		
		function QueueElement(ele,priority){
			this.element = ele;
			this.priority = priority;
		}
		
		this.enqueue = function(ele,priority){
			var queueEle = new QueueElement(ele,priority);
			//var _index = //items.findIndex(e=>e.priority>queueEle.priority)
			//if(_index < 0){
			//	items.push(queueEle)
			//} else {
			//	items.splice(_index,0,queueEle)
			//}
			// 注释的代码可以代替下面代码
			if(items.length<1){
				items.push(queueEle);
			} else {
				var added = false;
				for(var i=0;i<items.length;i++){
					if(queueEle.priority < items[i].priority){
						items.splice(i,0,queueEle);
						added = true;
						break;
					}
				}
				if(!added){
					items.push(queueEle)
				}
			}
			
		}
	}
	
	// 循环队列
	function hotPotato(names,num){
		var queue = new Queue();
		for(var i=0;i<names.length;i++){
			queue.enqueue(names[i]); // 将数据加入队列
		}
		var eliminated = '';
		while(queue.size() > 1){
			for(var i=0; i < num; i++){
				queue.enqueue(queue.dequeue());
			}
			eliminated = queue.dequeue();
			console.log('淘汰-->' + eliminated);
		}
		return queue.dequeue();
	}
	
	var names = ['A','B','C','D','E'];
	var winner = hotPotato(names, 7);
	console.log('winner-->' + winner);
	
3、链表
	链表存储有序的元素集合，不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。相对于传统的数组，链表的好处在于，添加或移除元素的时候不需要移动其他元素。
	
	① 创建链表
	function LinkList(){
		var Node = function(element){
			this.element = element;
			this.next = null;
		}
		
		var length = 0;
		var head = null;
		
		// 向列表尾部添加一个元素
		this.append = function(element){
			var node = new Node(element);
			var current;
			if(head===null){
				head = node;
			}else{
				current = head;
				while(current.next){
				// 取得最后一个元素，最后一个元素的next为Null
					current = current.next;
				}
				current.next = node;
			}
			length++;
		}
		
		// 向列表指定位置插入一个元素
		this.insert = function(position,element){
			if(position>-1 && position <= length){
				var node = new Node(element),
					current = head,
					previous,
					index = 0;
				if(position===0){
					node.next = current;
					head = node;
				} else {
					while(index++ < position){
						previous = current;
						current = current.next;
					}
					node.next = current;
					previous.next = node;
				}
				length++;
				return true;
			} else {
				return false;
			}
		}

		// 删除指定位置的元素
		this.removeAt = function(position){
			if(position>-1 && position<length){
				var current = head,
					previous,
					index = 0;
				if(position === 0){
					head = current.next;
				}else{
					while(index++ < position){
					// 这里需要取position位置的前一个元素,赋给previous
						previous = current;
					// 取到position位置的元素，previous的next就是position位置元素
						current = current.next;
					}
					// 将previous的next指向Position位置元素的下一个元素，达到跳过position位置元素的目的
					previous.next = current.next;
				}
				length--;
				return current.element;
			} else {
				return null;
			}
		}
		
		// 从列表中移除一个元素
		this.remove = function(element){}
		// 判断元素是否在列表中，如果在返回索引，否则返回-1
		this.indexOf = function(element){}
		this.isEmpty = function(){}
		this.size = function(){}
		this.toString = function(){}
		this.print = function(){}	
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
