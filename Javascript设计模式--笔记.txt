
One：单例模式--保证一个类仅有一个实例，并提供一个访问它的全局访问点。
	尽量减少全局变量污染
	1、使用命名空间
     var nameSpace = {
		a:function(){},
		b:function(){}
	 }
	 
	2、使用闭包封装私有变量
	 var user = (function(){
		var _name = 'laozhang',
		    _age = 29;
		return {
			getUserInfo:function(){return _name+'-'+_age}
		}
	 })()
	 
	3、通用惰性单例模式
	var getSingle = function(fn){
		var res;
		return function(){
			return res || (res = fn.apply(this,arguments))
		}
	}
	
Two: 策略模式--定义一系列的算法，把他们都封装起来，并使他们可以互相替换。
	var strategies = {
		"S": function(salary){return salary*4},
		"A": function(salary){return salary*3},
		"B": function(salary){return salary*2}
	}
	var calculateBonus = function(level,salary){
		return strategies[level](salary)
	}
	calculateBonus('S',5000) // 20000
	
Three：代理模式--为一个对象 提供一个代用品或占位符，以便控制对它的访问
	1、虚拟代理把一些开销很大的对象，延迟到真正需要的时候再去创建。例如；等图片加载好了之后再显示正确图片。
		var myImg = (function(){
			var imgNode = document.createElement('img');
			document.body.appendChild(imgNode);
			return { setSrc: function(src){ imgNode.src = src } }
		})();
		var proxyImg = (function(){
			var img = new Image;
			img.onload = function(){ myImg.setSrc(this.src); }
			return {
				setSrc: function(src){
					myImg.setSrc('localhost:8080/imgs/loading.gif');
					img.src = src;
				}
			}
		})();
		proxyImg.setSrc('http://imgcache.qq.com/qq.jpg');
	2、缓存代理可以为一些开销大的运算结果提供暂时的存储，再次运算时，如果传递过来的参数与之前的一致，则可以直接返回前面存储的运算结果。
		var mult = function(){
			var a = 1;
			for(var i=0;i<arguments.length;i++){
				a = a * arguments[i];
			}
			return a;
		}
		var proxyMult = (function(){
			var cache = {};
			return function(...arg){
				var args = agr.join(',');
				if(args in cache) return cache[args];
				return cache[args] = mult.apply(this,arg);
			}
		})();
		proxyMult(1,2,3,4)
	
Four: 迭代器模式--指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
	var each = function(arr,cb){
		for(var i=0,len=arr.length;i<len;i++){
			cb.call(arr[i],i,arr)
		}
	}
	each([1,2,3],function(item,index){})
	
Five：发布-订阅模式(观察者模式)--定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
	dom.addEventListener('eventName',fn)// JS中的发布-订阅模式
	var Event = (function(){
		var clientList = {},
			listen,
			trigger,
			remove;
		
		listen = function(key,fn){
			if(!clientList[key]){
				clientList[key] = [];
			}
			clientList[key].push(fn);
		}
		trigger = function(...arg){
			var key = arg.shift(),
				fns = clientList[key];
			if(!fns || fns.length<1){
				return false;
			}
			for(var i=0,fn;fn=fns[i++];){
				fn.apply(this,arg)
			}
		}
		remove = function(key,fn){
			var fns = clientList[key];
			if(!fns){
				return false
			}
			if(!fn){
				fns && (fns.length=0)
			}else {
				for(var l = 0; l < fns.length; l++){
					if(fns[l]==fn){
						fns.splice(l,1);
					}
				}
				
			}
		}
		return {
			listen: listen,
			trigger: trigger,
			remove: remove
		}
	})();
	var fnA = function(a){console.log(a+'AAAAA')}
	Event.listen('eventA',fnA)// 订阅
	Event.trigger('eventA','triggerA----')// 发布
	Event.remove('eventA',fnA)// 取消订阅

Six：命令模式--向某些对象发送请求，但并不知道请求的接受者是谁，也不知道被请求的操作是什么，发布命令者与接受者解耦
	var btn = document.querySellctor('btn');
	var setCommand = function(dom,command){
		dom.onclick = function(){command.excute()}//执行命令
	}
	var eventBar = {
		refresh: function(){//dosomething}
	}
	var RefreshCommand = function(receiver){
		return {
			excute:function(){
				receiver.refresh();
			}
		}
	}
	var refreshCommand = RefreshCommand(eventBar);
	setCommand(btn, refreshCommand)//发布命令
	
Seven：组合模式--组合模式将对象组合成属性结构，以表示“部分-整体”的层次结构。
	
	
	
	
	